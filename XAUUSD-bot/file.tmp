import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import threading
import logging
import time
import signal
import json
import warnings
from datetime import datetime, timedelta, timezone
import pytz
import numpy as np
import pandas as pd
import MetaTrader5 as mt5
import backoff
import functools
import traceback
import csv
import shutil
from STOCKDATA.modules.mmc_combo_strategy import MMCComboStrategy
from STOCKDATA.modules.indicators import calculate_atr, calculate_rsi
from STOCKDATA.utils.trade_logger import log_trade_execution

last_trade_candle = {}

# Suppress FutureWarning for pd.concat
warnings.filterwarnings("ignore", category=FutureWarning)

# File paths
TRADE_TIMES_FILE = "last_trade_times.json"
TRADE_LOG_FILE = "trades/trade_log.csv"
ACTIVE_TRADES_FILE = os.path.join("logs", "active_trades.json")

# Thread-safe dictionaries
last_trade_times = {}
active_trades = {}
data_lock = threading.Lock()

# Initialize basic logger
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s')
logger = logging.getLogger('trade_bot')

# Configure logging
def setup_logging():
    try:
        if not os.path.exists("logs"):
            os.makedirs("logs")
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('logs/trade_bot.log', encoding='utf-8'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        return logging.getLogger('trade_bot')
    except Exception as e:
        print(f"Error setting up logging: {str(e)}")
        return None

logger = setup_logging()

# Load config
def load_config():
    try:
        with open('config.json', 'r') as f:
            config = json.load(f)
            logger.info("Config loaded successfully")
            return config
    except FileNotFoundError:
        logger.error("Config file not found. Using default config.")
        default_config = {
            "symbols": ["XAUUSD"],
            "timeframe": "TIMEFRAME_M15",
            "candle_count": 50,
            "risk_settings": {
                "max_daily_trades": 10,
                "max_drawdown_pct": 0.1,
                "allow_multiple_trades": False
            },
            "logging": {
                "log_dir": "logs",
                "log_level": "INFO"
            },
            "mt5": {
                "login": 5036996416,
                "password": "6kZs-oPr",
                "server": "MetaQuotes-Demo"
            }
        }
        with open('config.json', 'w') as f:
            json.dump(default_config, f, indent=4)
        return default_config
    except Exception as e:
        logger.error(f"Error loading config: {str(e)}. Using default config.")
        return {
            "symbols": ["XAUUSD"],
            "timeframe": "TIMEFRAME_M15",
            "candle_count": 50,
            "risk_settings": {
                "max_daily_trades": 20,
                "max_drawdown_pct": 0.1,
                "allow_multiple_trades": False
            },
            "logging": {
                "log_dir": "logs",
                "log_level": "INFO"
            },
            "mt5": {
                "login": 5036996416,
                "password": "6kZs-oPr",
                "server": "MetaQuotes-Demo"
            }
        }

# Signal handler
def signal_handler(sig, frame):
    logger.info("Received shutdown signal. Saving state and shutting down MT5...")
    save_last_trade_times()
    save_active_trades()
    mt5.shutdown()
    sys.exit(0)

signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

# Load/Save trade times
def load_last_trade_times():
    global last_trade_times
    if os.path.exists(TRADE_TIMES_FILE):
        try:
            with open(TRADE_TIMES_FILE, 'r') as f:
                data = json.load(f)
                with data_lock:
                    last_trade_times.update({
                        strategy: datetime.fromisoformat(timestamp).replace(tzinfo=pytz.UTC)
                        for strategy, timestamp in data.items()
                    })
            logger.info(f"Loaded last trade times: {last_trade_times}")
        except Exception as e:
            logger.error(f"Error loading last trade times: {str(e)}")

def save_last_trade_times():
    try:
        os.makedirs(os.path.dirname(TRADE_TIMES_FILE) or '.', exist_ok=True)
        with data_lock:
            data_to_save = {strategy: timestamp.isoformat() for strategy, timestamp in last_trade_times.items()}
        with open(TRADE_TIMES_FILE, 'w') as f:
            json.dump(data_to_save, f)
        logger.debug(f"Saved last trade times: {data_to_save}")
    except Exception as e:
        logger.error(f"Error saving last trade times: {str(e)}")

# Load/Save active trades
def load_active_trades():
    global active_trades
    if os.path.exists(ACTIVE_TRADES_FILE):
        try:
            with open(ACTIVE_TRADES_FILE, 'r') as f:
                data = json.load(f)
                with data_lock:
                    active_trades.update({int(ticket): trade_info for ticket, trade_info in data.items()})
            logger.info(f"Loaded active trades: {active_trades}")
        except Exception as e:
            logger.error(f"Error loading active trades: {str(e)}")

def save_active_trades():
    try:
        os.makedirs(os.path.dirname(ACTIVE_TRADES_FILE) or '.', exist_ok=True)
        with data_lock:
            with open(ACTIVE_TRADES_FILE, 'w') as f:
                json.dump(active_trades, f)
        logger.debug(f"Saved active trades")
    except Exception as e:
        logger.error(f"Error saving active trades: {str(e)}")

# Log trade to CSV
def log_trade_to_csv(strategy_name, trade_type, lot_size, entry_time, sl, tp, comment, risk_amount, equity_before, equity_after, slippage=None, latency=None):
    try:
        if not os.path.exists("trades"):
            os.makedirs("trades")
        csv_file = "trades/trade_log.csv"
        trade_data = {
            'Strategy': strategy_name,
            'Trade Type': trade_type,
            'Lot Size': lot_size,
            'Entry Time': entry_time,
            'Stop Loss': sl,
            'Target': tp,
            'Comment': comment,
            'Risk Amount': risk_amount,
            'Equity Before Trade': equity_before,
            'Equity After Trade': equity_after,
            'Exit Time': '',
            'Profit': '',
            'Win/Loss': '',
            'Win Rate': '0.00%',
            'Total Loss Amount': 0.0,
            'Total Profit Amount': 0.0,
            'Total Trades': 0,
            'Profitability': 0.0,
            'Slippage': slippage,
            'Latency': latency
        }
        file_exists = os.path.exists(csv_file)
        with open(csv_file, 'a', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=trade_data.keys(), quoting=csv.QUOTE_NONNUMERIC)
            if not file_exists:
                writer.writeheader()
            writer.writerow(trade_data)
        logger.info(f"Trade logged to CSV: {csv_file}")
    except Exception as e:
        logger.error(f"Error logging trade to CSV: {str(e)}")

def update_trade_in_csv(ticket, exit_price, profit):
    try:
        csv_file = "trades/trade_log.csv"
        
        if not os.path.exists(csv_file):
            logger.error("Trade log file not found")
            return
            
        df = pd.read_csv(csv_file)
        trade_index = df[df['Comment'].str.contains(str(ticket))].index
        
        if len(trade_index) > 0:
            df.loc[trade_index, 'Exit Time'] = datetime.now(pytz.UTC).strftime('%Y-%m-%d %H:%M:%S')
            df.loc[trade_index, 'Profit'] = profit
            df.loc[trade_index, 'Win/Loss'] = 'WIN' if profit > 0 else 'LOSS'
            
            total_trades = len(df)
            winning_trades = len(df[df['Win/Loss'] == 'WIN'])
            win_rate = (winning_trades / total_trades * 100) if total_trades > 0 else 0
            
            df.loc[trade_index, 'Win Rate'] = f"{win_rate:.2f}%"
            df.loc[trade_index, 'Total Loss Amount'] = df[df['Win/Loss'] == 'LOSS']['Profit'].sum()
            df.loc[trade_index, 'Total Profit Amount'] = df[df['Win/Loss'] == 'WIN']['Profit'].sum()
            df.loc[trade_index, 'Total Trades'] = total_trades
            df.loc[trade_index, 'Profitability'] = (df['Total Profit Amount'].iloc[-1] / total_trades) if total_trades > 0 else 0
            
            df.to_csv(csv_file, index=False)
            logger.info(f"Trade {ticket} updated in CSV")
    except Exception as e:
        logger.error(f"Error updating trade in CSV: {str(e)}")

# Check risk limits
def check_risk_limits(config, equity):
    try:
        logger.info(f"Checking risk limits with equity: {equity}")
        initial_equity = equity
        if os.path.exists(TRADE_LOG_FILE):
            try:
                df = pd.read_csv(TRADE_LOG_FILE, on_bad_lines='skip')  # skip bad lines
            except Exception as e:
                logger.error(f"Error reading trade log CSV: {str(e)}. Skipping risk check.")
                return False
            if not df.empty and "Equity Before Trade" in df.columns:
                initial_equity = max(df["Equity Before Trade"].max(), equity)
        drawdown = (initial_equity - equity) / initial_equity if initial_equity > 0 else 0
        logger.info(f"Calculated drawdown: {drawdown*100:.2f}% (Initial Equity: {initial_equity}, Current Equity: {equity}, Max allowed: {config['risk_settings']['max_drawdown_pct']*100}%)")
        if drawdown > config["risk_settings"]["max_drawdown_pct"]:
            logger.warning(f"Max drawdown exceeded: {drawdown*100:.2f}%")
            return False
        logger.info("Risk limits check passed.")
        return True
    except Exception as e:
        logger.error(f"Error checking risk limits: {str(e)}. Skipping risk check.")
        return False

# Check open positions
def check_open_positions(symbol, allow_multiple_trades):
    try:
        positions = mt5.positions_get(symbol=symbol)
        if positions is None:
            logger.error(f"Failed to fetch positions for {symbol}")
            return True
        if len(positions) > 0:
            position_details = [{"ticket": pos.ticket, "type": "BUY" if pos.type == mt5.ORDER_TYPE_BUY else "SELL"} for pos in positions]
            logger.info(f"{len(positions)} open positions detected for {symbol}: {position_details}")
            if not allow_multiple_trades:
                logger.info("Multiple trades not allowed, skipping new trades.")
                return False
            logger.info("Multiple trades allowed, proceeding with trade checks.")
            return True
        logger.info(f"No open positions for {symbol}. Proceeding with trade checks.")
        return True
    except Exception as e:
        logger.error(f"Error in check_open_positions: {str(e)}")
        return True

# Manage open positions
def manage_open_positions(symbol, atr):
    try:
        if not ensure_mt5_connection():
            logger.error("MT5 not connected. Aborting manage_open_positions.")
            return
        positions = mt5.positions_get(symbol=symbol)
        if positions is None:
            return
        for pos in positions:
            strategy_name = pos.comment.split('_')[0]
            tick = mt5.symbol_info_tick(symbol)
            if tick is None:
                continue
            current_price = tick.bid if pos.type == mt5.ORDER_TYPE_BUY else tick.ask
            # Check if position is closed
            if pos.profit != 0 and (pos.sl == 0 or pos.tp == 0):
                update_trade_in_csv(pos.ticket, current_price, pos.profit)
                strategy_manager.remove_trade(strategy_name, symbol)
            # Send position update notification
            send_position_update_notification(pos)
            # Trailing stop logic
            if pos.type == mt5.ORDER_TYPE_BUY:
                price_move = current_price - pos.price_open
                if price_move > 0:
                    new_sl = current_price - (atr * 1.5)
                    if (pos.sl == 0) or (new_sl > pos.sl):
                        logger.info(f"[TRAILING SL] BUY {pos.ticket}: Current SL={pos.sl:.2f}, New SL={new_sl:.2f}, Price={current_price:.2f}")
                        request = {
                            "action": mt5.TRADE_ACTION_SLTP,
                            "position": pos.ticket,
                            "symbol": symbol,
                            "sl": new_sl,
                            "tp": pos.tp
                        }
                        result = mt5.order_send(request)
                        if result.retcode == mt5.TRADE_RETCODE_DONE:
                            logger.info(f"[SUCCESS] Trailing stop updated for BUY position {pos.ticket}")
                        else:
                            logger.error(f"[FAIL] Trailing stop update failed for BUY {pos.ticket}: {result.comment}")
            else:
                price_move = pos.price_open - current_price
                if price_move > 0:
                    new_sl = current_price + (atr * 1.5)
                    if (pos.sl == 0) or (new_sl < pos.sl):
                        logger.info(f"[TRAILING SL] SELL {pos.ticket}: Current SL={pos.sl:.2f}, New SL={new_sl:.2f}, Price={current_price:.2f}")
                        request = {
                            "action": mt5.TRADE_ACTION_SLTP,
                            "position": pos.ticket,
                            "symbol": symbol,
                            "sl": new_sl,
                            "tp": pos.tp
                        }
                        result = mt5.order_send(request)
                        if result.retcode == mt5.TRADE_RETCODE_DONE:
                            logger.info(f"[SUCCESS] Trailing stop updated for SELL position {pos.ticket}")
                        else:
                            logger.error(f"[FAIL] Trailing stop update failed for SELL {pos.ticket}: {result.comment}")
            # Partial close at TP1
            if pos.comment == "TradeBot_TP1" and \
               ((pos.type == mt5.ORDER_TYPE_BUY and current_price >= pos.tp) or \
                (pos.type == mt5.ORDER_TYPE_SELL and current_price <= pos.tp)):
                logger.info(f"TP1 hit for position {pos.ticket}, closing 50% of position")
                close_request = {
                    "action": mt5.TRADE_ACTION_DEAL,
                    "position": pos.ticket,
                    "symbol": symbol,
                    "volume": pos.volume * 0.5,
                    "type": mt5.ORDER_TYPE_SELL if pos.type == mt5.ORDER_TYPE_BUY else mt5.ORDER_TYPE_BUY,
                    "price": current_price,
                    "deviation": 20,
                    "magic": 123456,
                    "comment": "Partial Close",
                    "type_time": mt5.ORDER_TIME_GTC,
                    "type_filling": mt5.ORDER_FILLING_FOK
                }
                result = mt5.order_send(close_request)
                if result.retcode == mt5.TRADE_RETCODE_DONE:
                    logger.info(f"[SUCCESS] Successfully closed 50% of position at TP1")
                else:
                    logger.error(f"Failed to partially close position: {result.comment}")
    except Exception as e:
        logger.error(f"Error managing positions: {str(e)}")

# Common functions
def get_account_equity():
    try:
        if not ensure_mt5_connection():
            logger.error("MT5 not connected. Aborting get_account_equity.")
            return 10000
        account_info = mt5.account_info()
        if account_info is None:
            logger.error("Failed to get account info")
            return 10000
        equity = account_info.equity
        if equity <= 0:
            logger.error("Account equity is zero or negative.")
            return 10000
        return equity
    except Exception as e:
        logger.error(f"Error in get_account_equity: {str(e)}")
        return 10000

def calculate_dynamic_risk(equity, atr, sl_points, symbol):
    try:
        if atr is None or sl_points <= 0:
            logger.warning("Invalid ATR or SL points")
            return 0.01, equity * 0.01
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            logger.error(f"Symbol info for {symbol} unavailable")
            return 0.01, equity * 0.01
        atr_pct = atr / symbol_info.trade_contract_size
        risk_pct = min(max(0.005, atr_pct * 0.5), 0.02)
        risk_amount = equity * risk_pct
        return risk_pct, risk_amount
    except Exception as e:
        logger.error(f"Error in calculate_dynamic_risk: {str(e)}")
        return 0.01, equity * 0.01

def calculate_position_size(symbol, equity, atr, sl_points):
    try:
        if not ensure_mt5_connection():
            logger.error("MT5 not connected. Aborting calculate_position_size.")
            return 0.01
        max_risk_amount = equity * 0.01
        point_value = 100  # For XAUUSD
        risk_per_lot = sl_points * point_value
        lot_size = max_risk_amount / risk_per_lot
        lot_size = round(lot_size, 2)
        lot_size = max(0.01, min(lot_size, 1.0))
        logger.info(f"Position Size Calculation:")
        logger.info(f"  * Equity: ${equity:.2f}")
        logger.info(f"  * Max Risk: ${max_risk_amount:.2f}")
        logger.info(f"  * Risk per Lot: ${risk_per_lot:.2f}")
        logger.info(f"  * Calculated Lot Size: {lot_size}")
        return lot_size
    except Exception as e:
        logger.error(f"Error calculating position size: {str(e)}")
        return 0.01

def analyze_market_conditions(symbol, df):
    try:
        df['SMA20'] = df['close'].rolling(window=20).mean()
        df['SMA50'] = df['close'].rolling(window=50).mean()
        df['RSI'] = calculate_rsi(df['close'])
        current_price = df['close'].iloc[-1]
        current_rsi = df['RSI'].iloc[-1]
        current_sma20 = df['SMA20'].iloc[-1]
        current_sma50 = df['SMA50'].iloc[-1]
        market_conditions = {
            'trend': 'BULLISH' if current_sma20 > current_sma50 else 'BEARISH',
            'rsi_condition': 'OVERBOUGHT' if current_rsi > 70 else 'OVERSOLD' if current_rsi < 30 else 'NEUTRAL',
            'price_vs_sma20': 'ABOVE' if current_price > current_sma20 else 'BELOW',
            'volatility': 'HIGH' if df['close'].pct_change().std() > 0.002 else 'LOW'
        }
        logger.info(f"Market Analysis for {symbol}:")
        logger.info(f"  * Trend: {market_conditions['trend']}")
        logger.info(f"  * RSI: {current_rsi:.2f} ({market_conditions['rsi_condition']})")
        logger.info(f"  * Price vs SMA20: {market_conditions['price_vs_sma20']}")
        logger.info(f"  * Volatility: {market_conditions['volatility']}")
        return market_conditions
    except Exception as e:
        logger.error(f"Error analyzing market conditions: {str(e)}")
        return None

def track_strategy_performance():
    try:
        csv_file = "trades/trade_log.csv"
        if not os.path.exists(csv_file):
            return
        df = pd.read_csv(csv_file)
        performance = {
            'total_trades': len(df),
            'winning_trades': len(df[df['Win/Loss'] == 'WIN']),
            'losing_trades': len(df[df['Win/Loss'] == 'LOSS']),
            'total_profit': pd.to_numeric(df['Profit'], errors='coerce').sum(),
            'average_profit': pd.to_numeric(df['Profit'], errors='coerce').mean(),
            'max_profit': pd.to_numeric(df['Profit'], errors='coerce').max(),
            'max_loss': pd.to_numeric(df['Profit'], errors='coerce').min(),
            'win_rate': (len(df[df['Win/Loss'] == 'WIN']) / len(df) * 100) if len(df) > 0 else 0
        }
        strategy_performance = df.groupby('Strategy').agg({
            'Profit': ['count', 'sum', 'mean'],
            'Win/Loss': lambda x: (x == 'WIN').mean() * 100
        }).round(2)
        logger.info(f"\nStrategy Performance Report:")
        logger.info(f"  * Total Trades: {performance['total_trades']}")
        logger.info(f"  * Win Rate: {performance['win_rate']:.2f}%")
        logger.info(f"  * Total Profit: ${performance['total_profit']:.2f}")
        logger.info(f"  * Average Profit: ${performance['average_profit']:.2f}")
        logger.info(f"  * Max Profit: ${performance['max_profit']:.2f}")
        logger.info(f"  * Max Loss: ${performance['max_loss']:.2f}")
        logger.info(f"\nStrategy-wise Performance:")
        logger.info(f"{strategy_performance}")
    except Exception as e:
        logger.error(f"Error tracking strategy performance: {str(e)}")

# Ensure MT5 credentials are loaded from config
try:
    config = load_config()
    LOGIN = config["mt5"]["login"]
    PASSWORD = config["mt5"]["password"]
    SERVER = config["mt5"]["server"]
except Exception as e:
    LOGIN = PASSWORD = SERVER = None
    logger.error(f"Could not load MT5 credentials from config: {str(e)}")

def ensure_mt5_connection(max_retries=5, delay=10):
    """Ensure MT5 connection is active and working properly"""
    for attempt in range(max_retries):
        try:
            if not mt5.initialize():
                logger.error(f"MT5 initialization failed. Attempt {attempt + 1}/{max_retries}")
                time.sleep(delay)
                continue
                
            # Test connection by getting account info
            account_info = mt5.account_info()
            if account_info is None:
                logger.error(f"Failed to get account info. Attempt {attempt + 1}/{max_retries}")
                mt5.shutdown()
                time.sleep(delay)
                continue
                
            # Test market data access
            symbol_info = mt5.symbol_info("XAUUSD")
            if symbol_info is None:
                logger.error(f"Failed to get symbol info. Attempt {attempt + 1}/{max_retries}")
                mt5.shutdown()
                time.sleep(delay)
                continue
                
            logger.info("MT5 connection ensured.")
            return True
            
        except Exception as e:
            logger.error(f"Error ensuring MT5 connection: {str(e)}. Attempt {attempt + 1}/{max_retries}")
            try:
                mt5.shutdown()
            except:
                pass
            time.sleep(delay)
            
    logger.error("Failed to ensure MT5 connection after all attempts")
    return False

# Timeout decorator for MT5 calls
def timeout(seconds):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            result = [None]
            exception = [None]
            def target():
                try:
                    result[0] = func(*args, **kwargs)
                except Exception as e:
                    exception[0] = e
            thread = threading.Thread(target=target)
            thread.daemon = True
            thread.start()
            thread.join(seconds)
            if thread.is_alive():
                logger.error(f"Timeout: {func.__name__} took longer than {seconds} seconds")
                return None
            if exception[0] is not None:
                raise exception[0]
            return result[0]
        return wrapper
    return decorator

# Update place_order to log slippage/latency
@backoff.on_exception(backoff.expo, Exception, max_tries=3)
def place_order(symbol, order_type, volume, price, sl, tp, deviation=20, comment="TradeBot", strategy_name="", risk_amount=None):
    try:
        if not ensure_mt5_connection():
            logger.error("Skipping trade: MT5 connection not available")
            return False, None

        @timeout(5)
        def get_terminal_info():
            return mt5.terminal_info()

        terminal_info = get_terminal_info()
        if not terminal_info:
            logger.error("Failed to get terminal info")
            return False, None
        if not terminal_info.trade_allowed:
            logger.error("Auto-trading disabled in MT5. Please enable auto-trading.")
            return False, None

        @timeout(5)
        def get_symbol_info():
            return mt5.symbol_info(symbol)

        symbol_info = get_symbol_info()
        if symbol_info is None:
            logger.error(f"Symbol info for {symbol} unavailable")
            return False, None
        if not symbol_info.visible:
            logger.error(f"Symbol {symbol} not in Market Watch")
            return False, None
        if not symbol_info.trade_mode:
            logger.error(f"Trading disabled for {symbol}")
            return False, None
        digits = symbol_info.digits

        @timeout(5)
        def get_symbol_tick():
            return mt5.symbol_info_tick(symbol)

        tick = get_symbol_tick()
        if tick is None or tick.bid == 0 or tick.ask == 0:
            logger.error(f"No valid price feed: {symbol}")
            return False, None

        price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid
        price = round(price, digits)
        sl = round(sl, digits) if sl > 0 else 0
        tp = round(tp, digits) if tp > 0 else 0

        equity_before = get_account_equity()
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": volume,
            "type": order_type,
            "price": price,
            "sl": sl,
            "tp": tp,
            "deviation": deviation,
            "magic": 123456,
            "comment": comment,
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_FOK
        }
        logger.info(f"Attempting trade: Type={'BUY' if order_type == mt5.ORDER_TYPE_BUY else 'SELL'}, Price={price}, Lot={volume}, Risk={risk_amount}, SL={sl}, TP={tp}")
        start_time = time.time()
        @timeout(10)
        def send_order():
            return mt5.order_send(request)
        result = send_order()
        end_time = time.time()
        latency = end_time - start_time
        executed_price = getattr(result, 'price', price) if result else None
        slippage = abs(price - executed_price) if executed_price else None
        log_trade_to_csv(
            strategy_name=strategy_name,
            trade_type="BUY" if order_type == mt5.ORDER_TYPE_BUY else "SELL",
            lot_size=volume,
            entry_time=datetime.now(pytz.UTC).strftime("%Y-%m-%d %H:%M:%S"),
            sl=sl,
            tp=tp,
            comment=comment,
            risk_amount=risk_amount,
            equity_before=equity_before,
            equity_after=get_account_equity(),
            slippage=slippage,
            latency=latency
        )
        logger.debug(f"Finished logging trade to CSV for {symbol}, comment={comment}")

        ticket = result.order if result else None
        if ticket:
            try:
                with data_lock:
                    active_trades[ticket] = {
                        "strategy": strategy_name,
                        "type": "BUY" if order_type == mt5.ORDER_TYPE_BUY else "SELL",
                        "lot": volume,
                        "entry_time": datetime.now(pytz.UTC).strftime("%Y-%m-%d %H:%M:%S"),
                        "sl": sl,
                        "tp": tp,
                        "comment": comment,
                        "risk_amount": risk_amount,
                        "equity_before": equity_before,
                        "equity_after": get_account_equity(),
                        "symbol": symbol
                    }
                    save_active_trades()
                logger.debug(f"Successfully saved trade to active_trades for ticket {ticket}")
            except Exception as e:
                logger.error(f"Failed to save trade to active_trades for ticket {ticket}: {str(e)}")
                return False, None

        logger.info(f"Order placed successfully: {symbol}, {comment}, Ticket={ticket}")
        return True, ticket
    except Exception as e:
        logger.error(f"Error in place_order: {str(e)}")
        return False, None

@backoff.on_exception(backoff.expo, Exception, max_tries=3)
def get_price_with_slippage(symbol, order_type, slippage_points=5):
    try:
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            logger.error(f"Symbol info for {symbol} unavailable")
            return None
        tick = mt5.symbol_info_tick(symbol)
        if tick is None:
            logger.error(f"Tick data fetch failed: {symbol}")
            return None
        point = symbol_info.point
        price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid
        price = round(price + (slippage_points * point * (1 if order_type == mt5.ORDER_TYPE_BUY else -1)), symbol_info.digits)
        if price > 0:
            return price
        logger.error(f"Invalid price calculated: {price}")
        return None
    except Exception as e:
        logger.error(f"Error in get_price_with_slippage: {str(e)}")
        return None

def check_trade_limits(symbol, strategy_name):
    try:
        today = datetime.now(pytz.UTC).date()
        
        if os.path.exists(TRADE_LOG_FILE):
            df = pd.read_csv(TRADE_LOG_FILE)
            today_trades = df[
                (df["Strategy"] == strategy_name) & 
                (df["Entry Time"].str.contains(today.strftime("%Y-%m-%d")))
            ]
            
            if len(today_trades) >= 3:
                logger.info(f"‚ö†Ô∏è {strategy_name} has reached daily limit of 3 trades for {symbol}")
                return False
            else:
                logger.info(f"‚úÖ {strategy_name} has {3 - len(today_trades)} trades remaining today for {symbol}")
                
        return True
    except Exception as e:
        logger.error(f"‚ùå Error checking trade limits for {strategy_name}: {str(e)}")
        return True

class TradeHistory:
    def __init__(self):
        self.trade_history = {}
        self.min_time_between_trades = 60
        self.price_threshold = 0.5

    def can_trade(self, symbol, strategy_name, current_price):
        current_time = time.time()
        
        if symbol not in self.trade_history:
            self.trade_history[symbol] = {}
        if strategy_name not in self.trade_history[symbol]:
            self.trade_history[symbol][strategy_name] = [0, 0]
            
        last_trade_time, last_trade_price = self.trade_history[symbol][strategy_name]
        
        time_diff = current_time - last_trade_time
        if time_diff < self.min_time_between_trades:
            logger.info(f"‚è≥ {strategy_name} for {symbol}: Waiting {self.min_time_between_trades - time_diff:.0f} seconds before next trade")
            return False
            
        price_diff = abs(current_price - last_trade_price)
        if price_diff < self.price_threshold:
            logger.info(f"üìä {strategy_name} for {symbol}: Price hasn't moved enough ({price_diff:.2f} points)")
            return False
            
        return True

    def update_trade(self, symbol, strategy_name, price):
        self.trade_history[symbol][strategy_name] = [time.time(), price]
        logger.info(f"‚úÖ Updated trade history for {strategy_name} on {symbol} at {price:.2f}")

trade_history = TradeHistory()

class StrategyTradeManager:
    def __init__(self):
        self.active_trades = {}
        
    def can_open_trade(self, strategy_name, symbol):
        if strategy_name not in self.active_trades:
            self.active_trades[strategy_name] = {}
            
        if symbol in self.active_trades[strategy_name]:
            position = mt5.positions_get(ticket=self.active_trades[strategy_name][symbol])
            if position is not None and len(position) > 0:
                logger.info(f"[INFO] {strategy_name} already has an open trade for {symbol}")
                return False
            else:
                del self.active_trades[strategy_name][symbol]
                
        return True
        
    def add_trade(self, strategy_name, symbol, ticket):
        if strategy_name not in self.active_trades:
            self.active_trades[strategy_name] = {}
        self.active_trades[strategy_name][symbol] = ticket
        logger.info(f"[INFO] Added trade {ticket} to {strategy_name} tracking")
        
    def remove_trade(self, strategy_name, symbol):
        if strategy_name in self.active_trades and symbol in self.active_trades[strategy_name]:
            del self.active_trades[strategy_name][symbol]
            logger.info(f"[INFO] Removed trade from {strategy_name} tracking")

strategy_manager = StrategyTradeManager()

def send_trade_notification(strategy_name, symbol, order_type, price, sl, tp1, tp2, lot_size):
    try:
        notification = f"""
{'='*50}
NEW TRADE EXECUTED
{'='*50}
Strategy: {strategy_name}
Symbol: {symbol}
Type: {'BUY' if order_type == mt5.ORDER_TYPE_BUY else 'SELL'}
Entry Price: {price:.2f}
Stop Loss: {sl:.2f}
Take Profit 1: {tp1:.2f}
Take Profit 2: {tp2:.2f}
Lot Size: {lot_size}

Risk Analysis:
- Risk Amount: ${abs(price - sl) * lot_size * 100:.2f}
- Reward Amount: ${abs(tp1 - price) * lot_size * 100:.2f}
- Risk/Reward Ratio: {abs(tp1 - price) / abs(price - sl):.2f}

Time: {datetime.now(pytz.UTC).strftime('%Y-%m-%d %H:%M:%S %Z')}
{'='*50}
"""
        logger.info(notification)
        print("\033[92m" + notification + "\033[0m")
    except Exception as e:
        logger.error(f"Error sending trade notification: {str(e)}")

def log_trade_to_file(strategy_name, symbol, order_type, price, sl, tp1, tp2, lot_size, status="EXECUTED"):
    try:
        if not os.path.exists("trades"):
            os.makedirs("trades")
            
        filename = f"trades/trades_{datetime.now(pytz.UTC).strftime('%Y-%m-%d')}.txt"
        
        trade_details = f"""
{'='*50}
TRADE {status}
{'='*50}
Time: {datetime.now(pytz.UTC).strftime('%Y-%m-%d %H:%M:%S %Z')}
Strategy: {strategy_name}
Symbol: {symbol}
Type: {'BUY' if order_type == mt5.ORDER_TYPE_BUY else 'SELL'}
Entry Price: {price:.2f}
Stop Loss: {sl:.2f}
Take Profit 1: {tp1:.2f}
Take Profit 2: {tp2:.2f}
Lot Size: {lot_size}

Risk Analysis:
- Risk Amount: ${abs(price - sl) * lot_size * 100:.2f}
- Reward Amount: ${abs(tp1 - price) * lot_size * 100:.2f}
- Risk/Reward Ratio: {abs(tp1 - price) / abs(price - sl):.2f}
{'='*50}
"""
        with open(filename, 'a', encoding='utf-8') as f:
            f.write(trade_details)
            
        logger.info(f"Trade logged to {filename}")
    except Exception as e:
        logger.error(f"Error logging trade to file: {str(e)}")

def execute_trade(symbol, order_type, price, sl, tp1, tp2, lot_size, strategy_name):
    try:
        if not strategy_manager.can_open_trade(strategy_name, symbol):
            logger.info(f"[INFO] Skipping trade for {strategy_name} - Already has open position")
            return False

        # Fetch real-time price
        tick = mt5.symbol_info_tick(symbol)
        if tick is None or tick.bid == 0 or tick.ask == 0:
            logger.error(f"Failed to fetch real-time tick data for {symbol}. Aborting trade.")
            return False
        live_price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid
        logger.info(f"Using live price for trade: {live_price:.2f}")

        # Update SL and TP based on live price
        symbol_info = mt5.symbol_info(symbol)
        if symbol_info is None:
            logger.error(f"Symbol info for {symbol} unavailable")
            return False
        digits = symbol_info.digits
        live_price = round(live_price, digits)
        sl = round(sl, digits) if sl > 0 else 0
        tp1 = round(tp1, digits) if tp1 > 0 else 0
        tp2 = round(tp2, digits) if tp2 > 0 else 0

        # Calculate risk
        point_value = 100  # For XAUUSD
        risk = abs(live_price - sl) * lot_size * point_value
        risk_amount = risk
        reward = abs(tp1 - live_price) * lot_size * point_value
        rr = reward / risk if risk != 0 else 0
        logger.info(f"[RISK/REWARD] {strategy_name} | Symbol: {symbol} | Risk: {risk:.2f} | Reward: {reward:.2f} | RR: {rr:.2f}")

        # Place first TP order
        request = {
            "action": mt5.TRADE_ACTION_DEAL,
            "symbol": symbol,
            "volume": lot_size,
            "type": order_type,
            "price": live_price,
            "sl": sl,
            "tp": tp1,
            "deviation": 20,
            "magic": 123456,
            "comment": f"{strategy_name}_TP1",
            "type_time": mt5.ORDER_TIME_GTC,
            "type_filling": mt5.ORDER_FILLING_FOK
        }
        start_time = time.time()
        result = mt5.order_send(request)
        end_time = time.time()
        latency = end_time - start_time
        executed_price = getattr(result, 'price', live_price) if result else None
        slippage = abs(live_price - executed_price) if executed_price else None
        log_trade_to_csv(
            strategy_name=strategy_name,
            trade_type="BUY" if order_type == mt5.ORDER_TYPE_BUY else "SELL",
            lot_size=lot_size,
            entry_time=datetime.now(pytz.UTC).strftime("%Y-%m-%d %H:%M:%S"),
            sl=sl,
            tp=tp1,
            comment=f"{strategy_name}_TP1",
            risk_amount=risk_amount,
            equity_before=get_account_equity(),
            equity_after=get_account_equity(),
            slippage=slippage,
            latency=latency
        )
        if result.retcode != mt5.TRADE_RETCODE_DONE:
            logger.error(f"Trade failed: {result.comment}")
            return False
        strategy_manager.add_trade(strategy_name, symbol, result.order)
        logger.info(f"[SUCCESS] First TP order placed")

        # Place second TP order
        request["tp"] = tp2
        request["comment"] = f"{strategy_name}_TP2"
        start_time2 = time.time()
        result2 = mt5.order_send(request)
        end_time2 = time.time()
        latency2 = end_time2 - start_time2
        executed_price2 = getattr(result2, 'price', live_price) if result2 else None
        slippage2 = abs(live_price - executed_price2) if executed_price2 else None
        log_trade_to_csv(
            strategy_name=strategy_name,
            trade_type="BUY" if order_type == mt5.ORDER_TYPE_BUY else "SELL",
            lot_size=lot_size,
            entry_time=datetime.now(pytz.UTC).strftime("%Y-%m-%d %H:%M:%S"),
            sl=sl,
            tp=tp2,
            comment=f"{strategy_name}_TP2",
            risk_amount=risk_amount,
            equity_before=get_account_equity(),
            equity_after=get_account_equity(),
            slippage=slippage2,
            latency=latency2
        )
        if result2.retcode != mt5.TRADE_RETCODE_DONE:
            logger.error(f"Second TP order failed: {result2.comment}")
            return False
        logger.info(f"[SUCCESS] Second TP order placed")

        logger.info(f"[SUCCESS] Trade executed successfully for {strategy_name}")
        send_trade_notification(strategy_name, symbol, order_type, live_price, sl, tp1, tp2, lot_size)
        log_trade_to_file(strategy_name, symbol, order_type, live_price, sl, tp1, tp2, lot_size)
        return True
    except Exception as e:
        logger.error(f"Error executing trade: {str(e)}")
        return False

def log_position_update_to_file(position, update_type="UPDATE"):
    try:
        filename = f"trades/trades_{datetime.now(pytz.UTC).strftime('%Y-%m-%d')}.txt"
        
        update_details = f"""
{'='*50}
POSITION {update_type}
{'='*50}
Time: {datetime.now(pytz.UTC).strftime('%Y-%m-%d %H:%M:%S %Z')}
Ticket: {position.ticket}
Strategy: {position.comment.split('_')[0]}
Symbol: {position.symbol}
Type: {'BUY' if position.type == mt5.ORDER_TYPE_BUY else 'SELL'}
Current Price: {position.price_current:.2f}
Open Price: {position.price_open:.2f}
Stop Loss: {position.sl:.2f}
Take Profit: {position.tp:.2f}
Profit: ${position.profit:.2f}
Volume: {position.volume}
{'='*50}
"""
        with open(filename, 'a', encoding='utf-8') as f:
            f.write(update_details)
    except Exception as e:
        logger.error(f"Error logging position update to file: {str(e)}")

def send_position_update_notification(position):
    try:
        notification = f"""
{'='*50}
POSITION UPDATE
{'='*50}
Ticket: {position.ticket}
Strategy: {position.comment.split('_')[0]}
Symbol: {position.symbol}
Type: {'BUY' if position.type == mt5.ORDER_TYPE_BUY else 'SELL'}
Current Price: {position.price_current:.2f}
Open Price: {position.price_open:.2f}
Stop Loss: {position.sl:.2f}
Take Profit: {position.tp:.2f}
Profit: ${position.profit:.2f}
Volume: {position.volume}

Time: {datetime.now(pytz.UTC).strftime('%Y-%m-%d %H:%M:%S %Z')}
{'='*50}
"""
        logger.info(notification)
        print("\033[93m" + notification + "\033[0m")
    except Exception as e:
        logger.error(f"Error sending position update notification: {str(e)}")

# Equity curve protection
EQUITY_CURVE_MA_PERIOD = 20
MAX_CONSECUTIVE_LOSSES = 5
consecutive_losses = 0
last_equity_curve = []
trading_paused_due_to_equity = False

def check_equity_curve_protection(equity):
    global last_equity_curve, trading_paused_due_to_equity, consecutive_losses
    last_equity_curve.append(equity)
    if len(last_equity_curve) > EQUITY_CURVE_MA_PERIOD:
        last_equity_curve.pop(0)
    if len(last_equity_curve) == EQUITY_CURVE_MA_PERIOD:
        ma = sum(last_equity_curve) / EQUITY_CURVE_MA_PERIOD
        if equity < ma * 0.98 or consecutive_losses >= MAX_CONSECUTIVE_LOSSES:
            trading_paused_due_to_equity = True
            logger.warning("Trading paused due to equity curve protection.")
        else:
            trading_paused_due_to_equity = False
    return not trading_paused_due_to_equity

# Portfolio/correlation management
CORRELATION_THRESHOLD = 0.8

def check_portfolio_correlation(symbol):
    positions = mt5.positions_get()
    if not positions:
        return True
    open_symbols = {pos.symbol for pos in positions}
    correlated = set(["XAUEUR", "XAGUSD"])
    if symbol in correlated and any(s in open_symbols for s in correlated):
        logger.info(f"Correlation filter: {symbol} correlated exposure detected. Skipping trade.")
        return False
    return True

# Global risk limits
MAX_GLOBAL_TRADES_PER_DAY = 10
MAX_GLOBAL_DRAWDOWN_PCT = 0.1
MAX_GLOBAL_OPEN_POSITIONS = 5
last_trade_day = None

def reset_daily_trade_count():
    global last_trade_day
    today = datetime.now(pytz.UTC).date()
    if last_trade_day != today:
        logger.info(f"Resetting daily trade count for new day: {today}")
        last_trade_day = today
        # Optionally, you can clear trade history for the new day if needed
        # trade_history.trade_history.clear()

def check_global_risk_limits():
    try:
        reset_daily_trade_count()  # Check and reset daily trade count if new day
        today = datetime.now(timezone.utc).date()
        trade_count = 0
        if os.path.exists(TRADE_LOG_FILE):
            try:
                df = pd.read_csv(TRADE_LOG_FILE, on_bad_lines='skip')  # skip bad lines
            except Exception as e:
                logger.error(f"Error reading trade log CSV in global risk limits: {str(e)}. Skipping global risk check.")
                return True  # Don't block trading if CSV is bad
            today_trades = df[df["Entry Time"].str.contains(today.strftime("%Y-%m-%d"))]
            trade_count = len(today_trades)
            logger.info(f"Today's trade count: {trade_count}/{MAX_GLOBAL_TRADES_PER_DAY}")
            if trade_count >= MAX_GLOBAL_TRADES_PER_DAY:
                logger.warning("Max global trades per day reached.")
                return False
        positions = mt5.positions_get()
        if positions and len(positions) >= MAX_GLOBAL_OPEN_POSITIONS:
            logger.warning("Max global open positions reached.")
            return False
        equity = get_account_equity()
        if os.path.exists(TRADE_LOG_FILE):
            try:
                df = pd.read_csv(TRADE_LOG_FILE, on_bad_lines='skip')
            except Exception as e:
                logger.error(f"Error reading trade log CSV in global risk limits (drawdown): {str(e)}. Skipping drawdown check.")
                return True
            if not df.empty and "Equity Before Trade" in df.columns:
                initial_equity = max(df["Equity Before Trade"].max(), equity)
                drawdown = (initial_equity - equity) / initial_equity if initial_equity > 0 else 0
                if drawdown > MAX_GLOBAL_DRAWDOWN_PCT:
                    logger.warning("Max global drawdown exceeded.")
                    return False
        return True
    except Exception as e:
        logger.error(f"Error checking global risk limits: {str(e)}. Skipping global risk check.")
        return True  # Don't block trading if error

def send_alert(message):
    logger.info(f"[ALERT] {message}")

def push_to_dashboard(data):
    logger.debug(f"[DASHBOARD] {data}")

def log_broker_metrics(order_result, latency=None):
    if order_result is not None:
        logger.info(f"Order Result: retcode={order_result.retcode}, comment={order_result.comment}, latency={latency}")
    else:
        logger.warning(f"Order Result: None, latency={latency}")

# Strategy Classes
class mmxm:
    def execute(self, symbol, prices, df, equity, allow_multiple_trades):
        try:
            logger.info(f"Executing mmxm | Symbol: {symbol} | Capital: ${equity:.2f}")
            candle_time = df['time'].iloc[-1] if 'time' in df.columns else len(df)
            key = (symbol, 'mmxm')
            if last_trade_candle.get(key) == candle_time:
                logger.info(f"[SKIP] Trade already executed for this candle: {candle_time}")
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if not check_trade_limits(symbol, "mmxm"):
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            range_high = float(max(prices[-10:]))
            range_low = float(min(prices[-10:]))
            avg_price = (range_high + range_low) / 2
            range_pct = (range_high - range_low) / avg_price
            atr = calculate_atr(df)
            if atr is None:
                return {"success": False, "is_win": False, "risk_amount": 0.0}
            is_consolidation = range_pct < 0.005
            is_sweep = False
            direction = None
            if prices[-1] > range_high * 1.002 and prices[-2] < range_high:
                is_sweep = True
                direction = "bearish"
            elif prices[-1] < range_low * 0.998 and prices[-2] > range_low:
                is_sweep = True
                direction = "bullish"
            if is_sweep and is_consolidation:
                logger.info(f"MMXM {direction} sweep detected")
                tick = mt5.symbol_info_tick(symbol)
                if tick is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                order_type = mt5.ORDER_TYPE_SELL if direction == "bearish" else mt5.ORDER_TYPE_BUY
                price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid
                sl = price - (atr * 1.5) if order_type == mt5.ORDER_TYPE_BUY else price + (atr * 1.5)
                sl_points = abs(price - sl) / mt5.symbol_info(symbol).point
                lot_size = calculate_position_size(symbol, equity, atr, sl_points)
                tp1 = price + (sl_points * mt5.symbol_info(symbol).point) if order_type == mt5.ORDER_TYPE_BUY else price - (sl_points * mt5.symbol_info(symbol).point)
                tp2 = price + (sl_points * 2 * mt5.symbol_info(symbol).point) if order_type == mt5.ORDER_TYPE_BUY else price - (sl_points * 2 * mt5.symbol_info(symbol).point)
                success = execute_trade(symbol, order_type, price, sl, tp1, tp2, lot_size, "mmxm")
                if success:
                    last_trade_candle[key] = candle_time
                return {"success": success, "is_win": success, "risk_amount": equity * 0.01}
            return {"success": True, "is_win": False, "risk_amount": 0.0}
        except Exception as e:
            logger.error(f"Error in mmxm: {str(e)}")
            return {"success": False, "is_win": False, "risk_amount": 0.0}

class msb_retest:
    def execute(self, symbol, prices, df, equity, allow_multiple_trades):
        try:
            logger.info(f"Executing msb_retest | Symbol: {symbol} | Capital: ${equity:.2f}")
            candle_time = df['time'].iloc[-1] if 'time' in df.columns else len(df)
            key = (symbol, 'msb_retest')
            if last_trade_candle.get(key) == candle_time:
                logger.info(f"[SKIP] Trade already executed for this candle: {candle_time}")
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if not check_trade_limits(symbol, "msb_retest"):
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if prices[-1] > max(prices[:-1]) and prices[-2] < max(prices[:-2]):
                logger.info("Bullish MSB detected")
                tick = mt5.symbol_info_tick(symbol)
                if tick is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                order_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
                atr = calculate_atr(df)
                if atr is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                sl = price - (atr * 1.5)
                sl_points = abs(price - sl) / mt5.symbol_info(symbol).point
                lot_size = calculate_position_size(symbol, equity, atr, sl_points)
                tp1 = price + (sl_points * mt5.symbol_info(symbol).point)
                tp2 = price + (sl_points * 2 * mt5.symbol_info(symbol).point)
                success = execute_trade(symbol, order_type, price, sl, tp1, tp2, lot_size, "msb_retest")
                if success:
                    last_trade_candle[key] = candle_time
                return {"success": success, "is_win": success, "risk_amount": equity * 0.01}
            return {"success": True, "is_win": False, "risk_amount": 0.0}
        except Exception as e:
            logger.error(f"Error in msb_retest: {str(e)}")
            return {"success": False, "is_win": False, "risk_amount": 0.0}

class order_block:
    def execute(self, symbol, prices, df, equity, allow_multiple_trades):
        try:
            logger.info(f"Executing order_block | Symbol: {symbol} | Capital: ${equity:.2f}")
            candle_time = df['time'].iloc[-1] if 'time' in df.columns else len(df)
            key = (symbol, 'order_block')
            if last_trade_candle.get(key) == candle_time:
                logger.info(f"[SKIP] Trade already executed for this candle: {candle_time}")
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if not check_trade_limits(symbol, "order_block"):
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if prices[-1] < np.mean(prices[-10:]) and prices[-2] > np.mean(prices[-10:]):
                logger.info("Bullish order block detected")
                tick = mt5.symbol_info_tick(symbol)
                if tick is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                order_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
                atr = calculate_atr(df)
                if atr is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                sl = price - (atr * 1.5)
                sl_points = abs(price - sl) / mt5.symbol_info(symbol).point
                lot_size = calculate_position_size(symbol, equity, atr, sl_points)
                tp1 = price + (sl_points * mt5.symbol_info(symbol).point)
                tp2 = price + (sl_points * 2 * mt5.symbol_info(symbol).point)
                success = execute_trade(symbol, order_type, price, sl, tp1, tp2, lot_size, "order_block")
                if success:
                    last_trade_candle[key] = candle_time
                return {"success": success, "is_win": success, "risk_amount": equity * 0.01}
            return {"success": True, "is_win": False, "risk_amount": 0.0}
        except Exception as e:
            logger.error(f"Error in order_block: {str(e)}")
            return {"success": False, "is_win": False, "risk_amount": 0.0}

class ote:
    def execute(self, symbol, prices, df, equity, allow_multiple_trades):
        try:
            logger.info(f"Executing ote | Symbol: {symbol} | Capital: ${equity:.2f}")
            candle_time = df['time'].iloc[-1] if 'time' in df.columns else len(df)
            key = (symbol, 'ote')
            if last_trade_candle.get(key) == candle_time:
                logger.info(f"[SKIP] Trade already executed for this candle: {candle_time}")
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if not check_trade_limits(symbol, "ote"):
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if prices[-1] < np.percentile(prices[-20:], 30):
                logger.info("OTE buy zone detected")
                tick = mt5.symbol_info_tick(symbol)
                if tick is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                order_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
                atr = calculate_atr(df)
                if atr is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                sl = price - (atr * 1.5)
                sl_points = abs(price - sl) / mt5.symbol_info(symbol).point
                lot_size = calculate_position_size(symbol, equity, atr, sl_points)
                tp1 = price + (sl_points * mt5.symbol_info(symbol).point)
                tp2 = price + (sl_points * 2 * mt5.symbol_info(symbol).point)
                success = execute_trade(symbol, order_type, price, sl, tp1, tp2, lot_size, "ote")
                if success:
                    last_trade_candle[key] = candle_time
                return {"success": success, "is_win": success, "risk_amount": equity * 0.01}
            return {"success": True, "is_win": False, "risk_amount": 0.0}
        except Exception as e:
            logger.error(f"Error in ote: {str(e)}")
            return {"success": False, "is_win": False, "risk_amount": 0.0}

class amd_strategy:
    def execute(self, symbol, prices, df, equity, allow_multiple_trades):
        try:
            logger.info(f"Executing amd_strategy | Symbol: {symbol} | Capital: ${equity:.2f}")
            candle_time = df['time'].iloc[-1] if 'time' in df.columns else len(df)
            key = (symbol, 'amd_strategy')
            if last_trade_candle.get(key) == candle_time:
                logger.info(f"[SKIP] Trade already executed for this candle: {candle_time}")
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if not check_trade_limits(symbol, "amd_strategy"):
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            price_range = float(max(prices[-10:])) - float(min(prices[-10:]))
            atr = calculate_atr(df)
            if atr is None:
                return {"success": False, "is_win": False, "risk_amount": 0.0}
            if price_range < atr:
                logger.info("Accumulation phase detected")
                tick = mt5.symbol_info_tick(symbol)
                if tick is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                order_type = mt5.ORDER_TYPE_BUY
                price = tick.ask
                sl = price - (atr * 1.5)
                sl_points = abs(price - sl) / mt5.symbol_info(symbol).point
                lot_size = calculate_position_size(symbol, equity, atr, sl_points)
                tp1 = price + (sl_points * mt5.symbol_info(symbol).point)
                tp2 = price + (sl_points * 2 * mt5.symbol_info(symbol).point)
                success = execute_trade(symbol, order_type, price, sl, tp1, tp2, lot_size, "amd_strategy")
                if success:
                    last_trade_candle[key] = candle_time
                return {"success": success, "is_win": success, "risk_amount": equity * 0.01}
            return {"success": True, "is_win": False, "risk_amount": 0.0}
        except Exception as e:
            logger.error(f"Error in amd_strategy: {str(e)}")
            return {"success": False, "is_win": False, "risk_amount": 0.0}

class judas_swing:
    def execute(self, symbol, prices, df, equity, allow_multiple_trades):
        try:
            logger.info(f"Executing judas_swing | Symbol: {symbol} | Capital: ${equity:.2f}")
            candle_time = df['time'].iloc[-1] if 'time' in df.columns else len(df)
            key = (symbol, 'judas_swing')
            if last_trade_candle.get(key) == candle_time:
                logger.info(f"[SKIP] Trade already executed for this candle: {candle_time}")
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if not check_trade_limits(symbol, "judas_swing"):
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if prices[-1] > max(prices[:-1]) and prices[-2] < max(prices[:-2]):
                logger.info("False breakout (Judas Swing) detected")
                tick = mt5.symbol_info_tick(symbol)
                if tick is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                order_type = mt5.ORDER_TYPE_SELL
                price = tick.bid
                atr = calculate_atr(df)
                if atr is None:
                    return {"success": False, "is_win": False, "risk_amount": 0.0}
                sl = price + (atr * 1.5)
                sl_points = abs(price - sl) / mt5.symbol_info(symbol).point
                lot_size = calculate_position_size(symbol, equity, atr, sl_points)
                tp1 = price - (sl_points * mt5.symbol_info(symbol).point)
                tp2 = price - (sl_points * 2 * mt5.symbol_info(symbol).point)
                success = execute_trade(symbol, order_type, price, sl, tp1, tp2, lot_size, "judas_swing")
                if success:
                    last_trade_candle[key] = candle_time
                return {"success": success, "is_win": success, "risk_amount": equity * 0.01}
            return {"success": True, "is_win": False, "risk_amount": 0.0}
        except Exception as e:
            logger.error(f"Error in judas_swing: {str(e)}")
            return {"success": False, "is_win": False, "risk_amount": 0.0}

def initialize_mt5():
    max_retries = 3
    for attempt in range(max_retries):
        try:
            if not mt5.initialize():
                logger.error(f"MT5 initialization failed. Error code: {mt5.last_error()}")
                logger.info("Attempting to reconnect...")
                time.sleep(5)
                continue
            if not mt5.login(login=LOGIN, password=PASSWORD, server=SERVER):
                logger.error(f"MT5 login failed. Error code: {mt5.last_error()}")
                logger.info("Attempting to reconnect...")
                time.sleep(5)
                continue
            logger.info("MT5 connection restored successfully")
            return True
        except Exception as e:
            logger.error(f"Error in handle_mt5_error: {str(e)}")
            return False
    return False

@backoff.on_exception(backoff.expo, Exception, max_tries=3)
def fetch_candles(symbol, timeframe, count):
    max_retries = 3
    for attempt in range(max_retries):
        try:
            if not ensure_mt5_connection():
                logger.error("MT5 not connected. Aborting fetch_candles.")
                time.sleep(10)
                continue
            symbol_info = mt5.symbol_info(symbol)
            if symbol_info is None or not symbol_info.visible:
                if not mt5.symbol_select(symbol, True):
                    logger.error(f"Symbol {symbol} not found in Market Watch.")
                    time.sleep(10)
                    continue
                symbol_info = mt5.symbol_info(symbol)
                if symbol_info is None:
                    logger.error(f"Symbol {symbol} still not available after selection.")
                    time.sleep(10)
                    continue

            tick = mt5.symbol_info_tick(symbol)
            if tick is None or tick.bid == 0 or tick.ask == 0:
                logger.warning(f"No valid quotes for {symbol}. Market may be closed or disconnected. Attempt {attempt+1}/{max_retries}")
                time.sleep(30 if attempt == max_retries-1 else 10)
                continue

            utc_now = datetime.now(timezone.utc)
            tf_map = {
                mt5.TIMEFRAME_M1: 1,
                mt5.TIMEFRAME_M5: 5,
                mt5.TIMEFRAME_M15: 15,
                mt5.TIMEFRAME_M30: 30,
                mt5.TIMEFRAME_H1: 60,
                mt5.TIMEFRAME_H4: 240,
                mt5.TIMEFRAME_D1: 1440
            }
            minutes_per_candle = tf_map.get(timeframe, 1)
            utc_from = utc_now - timedelta(minutes=count * minutes_per_candle)
            rates = mt5.copy_rates_range(symbol, timeframe, utc_from, utc_now)
            if rates is None or len(rates) == 0:
                logger.warning(f"Failed to fetch candles for {symbol}. Attempt {attempt+1}/{max_retries}")
                time.sleep(10)
                continue

            df = pd.DataFrame(rates)
            df['time'] = pd.to_datetime(df['time'], unit='s', utc=True)
            for col in ['open', 'high', 'low', 'close', 'tick_volume']:
                df[col] = pd.to_numeric(df[col], errors='coerce')
            if df[['open', 'high', 'low', 'close']].isnull().any().any():
                logger.warning(f"DataFrame contains NaN values in price columns for {symbol}. Attempt {attempt+1}/{max_retries}")
                time.sleep(10)
                continue
            prices = df['close'].to_numpy(dtype=np.float64)
            latest_candle_time = df['time'].iloc[-1]
            max_age = minutes_per_candle * 90  # 1.5x in seconds
            time_diff = (utc_now - latest_candle_time).total_seconds()
            if time_diff > max_age:
                logger.warning(f"Latest candle is too old: {time_diff:.2f} seconds (max allowed: {max_age}). Attempt {attempt+1}/{max_retries}")
                time.sleep(10)
                continue
            logger.info(f"Fetched {len(prices)} candles for {symbol}. Latest candle time: {latest_candle_time}, Latest price: {prices[-1]:.2f}")
            return df, prices
        except Exception as e:
            logger.error(f"Error fetching candles (attempt {attempt+1}/{max_retries}): {str(e)}")
            time.sleep(10)
    logger.error(f"[FATAL] Could not fetch fresh candles for {symbol} after {max_retries} attempts. Will retry next cycle.")
    return None

def run_strategy_for_symbol(symbol, timeframe, count, strategies, config):
    allow_multiple_trades = config["risk_settings"].get("allow_multiple_trades", False)
    tf_map = {
        mt5.TIMEFRAME_M1: 1,
        mt5.TIMEFRAME_M5: 5,
        mt5.TIMEFRAME_M15: 15,
        mt5.TIMEFRAME_M30: 30,
        mt5.TIMEFRAME_H1: 60,
        mt5.TIMEFRAME_H4: 240,
        mt5.TIMEFRAME_D1: 1440
    }
    # --- STRATEGY PRIORITY ---
    strategy_priority = {
        "judas_swing": 1,
        "mmxm": 2, "amd_strategy": 2, "mmc_strategy": 2,
        "mmc_combo_strategy": 3, "msb_retest": 3, "order_block": 3, "ote": 3
    }
    last_candle_time = None
    while True:
        try:
            cycle_start_time = time.time()
            cycle_start_datetime = datetime.now(timezone.utc)
            logger.info(f"\n{'='*50}")
            logger.info(f"NEW CYCLE STARTED")
            logger.info(f"Time: {cycle_start_datetime.strftime('%Y-%m-%d %H:%M:%S %Z')}")
            logger.info(f"Symbol: {symbol}")
            logger.info(f"{'='*50}")

            # Fetch candle data
            data = fetch_candles(symbol, timeframe, count)
            if data is None:
                logger.error(f"No price data for {symbol}. Skipping this cycle...")
                time.sleep(60)
                continue
            df, prices = data
            latest_candle_close = prices[-1]
            latest_candle_time = df['time'].iloc[-1]

            # Only run strategies if a new candle has appeared
            if last_candle_time is not None and latest_candle_time == last_candle_time:
                logger.info(f"No new candle for {symbol}. Waiting for next candle...")
                time.sleep(60)
                continue
            last_candle_time = latest_candle_time

            # Fetch real-time price
            tick = mt5.symbol_info_tick(symbol)
            if tick is None or tick.bid == 0 or tick.ask == 0:
                logger.error(f"Failed to fetch real-time tick data for {symbol}. Skipping this cycle...")
                time.sleep(60)
                continue
            live_price = tick.ask if symbol == "XAUUSD" else tick.bid

            # Log live price and candle close price
            logger.info(f"Price Data for {symbol}:")
            logger.info(f"  * Live Price: {live_price:.2f}")
            logger.info(f"  * Latest Candle Close: {latest_candle_close:.2f}")

            # Check price difference
            price_diff_pct = abs(live_price - latest_candle_close) / latest_candle_close * 100
            if price_diff_pct > MAX_PRICE_DIFF_PCT:
                logger.warning(
                    f"Price difference too large: {price_diff_pct:.2f}% (>{MAX_PRICE_DIFF_PCT}%). "
                    f"Live: {live_price:.2f}, Candle Close: {latest_candle_close:.2f}. Skipping trades..."
                )
                time.sleep(60)
                continue

            # Check candle freshness (1.5x timeframe)
            current_utc_time = datetime.now(timezone.utc)
            minutes_per_candle = tf_map.get(timeframe, 1)
            max_age = minutes_per_candle * 90  # 1.5x in seconds
            time_diff = (current_utc_time - latest_candle_time).total_seconds()
            if time_diff > max_age:
                logger.warning(f"Latest candle is too old: {time_diff:.2f} seconds (max allowed: {max_age}). Skipping trades...")
                time.sleep(60)
                continue

            # Analyze market conditions
            market_conditions = analyze_market_conditions(symbol, df)
            atr = calculate_atr(df)
            if atr is not None:
                logger.info(f"Market Analysis:")
                logger.info(f"  * ATR: {atr:.2f}")
                logger.info(f"  * Current Price: {live_price:.2f}")
                logger.info(f"  * Price Change: {((live_price - prices[-2])/prices[-2]*100):.2f}%")
                manage_open_positions(symbol, atr)

            # Get account equity
            equity = get_account_equity()
            logger.info(f"Account Status:")
            logger.info(f"  * Equity: ${equity:.2f}")

            # Risk and limit checks
            if not check_risk_limits(config, equity):
                logger.warning(f"Risk limits exceeded for {symbol}. Skipping this cycle...")
                time.sleep(60)
                continue
            if not check_equity_curve_protection(equity):
                logger.warning("Equity curve protection triggered. Skipping all strategies this cycle.")
                time.sleep(60)
                continue
            if not check_portfolio_correlation(symbol):
                logger.warning("Portfolio correlation filter triggered. Skipping all strategies this cycle.")
                time.sleep(60)
                continue
            if not check_global_risk_limits():
                logger.warning("Global risk limits triggered. Skipping all strategies this cycle.")
                time.sleep(60)
                continue

            # --- COLLECT STRATEGY SIGNALS ---
            signals = []
            ml_filter = MLTradeFilter()  # Initialize ML filter
            
            for strategy_name, strategy in sorted(strategies, key=lambda x: strategy_priority.get(x[0], 99)):
                try:
                    logger.info(f"\nChecking {strategy_name} for {symbol}...")
                    logger.info(f"Executing {strategy_name} | Symbol: {symbol} | Capital: ${equity:.2f}")
                    
                    # Check trade limits before executing strategy
                    if not check_trade_limits(symbol, strategy_name):
                        logger.info(f"‚úÖ {strategy_name} has {3} trades remaining today for {symbol}")
                        continue
                        
                    # Execute strategy with proper error handling
                    try:
                        result = strategy.execute(symbol, prices, df, equity, allow_multiple_trades)
                    except Exception as e:
                        logger.error(f"Error executing {strategy_name}: {str(e)}")
                        continue
                        
                    # Validate strategy result
                    if not result or not isinstance(result, dict):
                        logger.warning(f"[WARNING] {strategy_name} returned invalid result")
                        continue
                        
                    # Check if strategy execution was successful
                    if not result.get("success", False):
                        logger.info(f"[INFO] {strategy_name} no trade setup found")
                        continue
                        
                    # Extract features for ML filter
                    features = result.get("features", [])
                    if features and not ml_filter.allow_trade(features):
                        logger.info(f"[FILTERED] {strategy_name} trade filtered by ML model")
                        continue
                        
                    # Validate required trade parameters
                    required_params = ["direction", "price", "sl", "tp1", "tp2", "lot_size"]
                    missing_params = [param for param in required_params if not result.get(param)]
                    if missing_params:
                        logger.warning(f"[WARNING] {strategy_name} missing required parameters: {missing_params}")
                        continue
                        
                    logger.info(f"[SUCCESS] {strategy_name} check completed")
                    signals.append({
                        "strategy": strategy_name,
                        "priority": strategy_priority.get(strategy_name, 99),
                        "direction": result["direction"],
                        "lot_size": min(max(result["lot_size"], 0.01), 1.0),
                        "tp1": result["tp1"],
                        "tp2": result["tp2"],
                        "sl": result["sl"],
                        "price": result["price"],
                        "atr": atr,
                        "win_probability": ml_filter.get_win_probability(features) if features else 0.5
                    })
                except Exception as e:
                    logger.error(f"[ERROR] Error executing strategy {strategy_name}: {str(e)}")
                    continue

            # --- RESOLVE CONFLICTS & EXECUTE TRADES ---
            # Find highest-priority direction
            buy_signals = [s for s in signals if s["direction"] == "buy"]
            sell_signals = [s for s in signals if s["direction"] == "sell"]
            open_positions = mt5.positions_get(symbol=symbol)
            open_buy = any(p.type == mt5.ORDER_TYPE_BUY for p in open_positions) if open_positions else False
            open_sell = any(p.type == mt5.ORDER_TYPE_SELL for p in open_positions) if open_positions else False
            # Priority logic
            if buy_signals and (not open_sell or (open_sell and buy_signals[0]["priority"] < min([s["priority"] for s in sell_signals], default=99))):
                # Allow all buy signals, unless a higher-priority sell exists
                for sig in buy_signals:
                    lot = sig["lot_size"]
                    if lot > 0.8:
                        lot1 = lot2 = lot / 2
                    else:
                        lot1 = lot
                        lot2 = 0
                    # Place buy trade with partial profit logic
                    execute_trade(symbol, mt5.ORDER_TYPE_BUY, sig["price"], sig["sl"], sig["tp1"], sig["tp2"], lot1, sig["strategy"])
                    if lot2 > 0:
                        execute_trade(symbol, mt5.ORDER_TYPE_BUY, sig["price"], sig["sl"], sig["tp2"], None, lot2, sig["strategy"])
            elif sell_signals and (not open_buy or (open_buy and sell_signals[0]["priority"] < min([s["priority"] for s in buy_signals], default=99))):
                # Allow all sell signals, unless a higher-priority buy exists
                for sig in sell_signals:
                    lot = sig["lot_size"]
                    if lot > 0.8:
                        lot1 = lot2 = lot / 2
                    else:
                        lot1 = lot
                        lot2 = 0
                    # Place sell trade with partial profit logic
                    execute_trade(symbol, mt5.ORDER_TYPE_SELL, sig["price"], sig["sl"], sig["tp1"], sig["tp2"], lot1, sig["strategy"])
                    if lot2 > 0:
                        execute_trade(symbol, mt5.ORDER_TYPE_SELL, sig["price"], sig["sl"], sig["tp2"], None, lot2, sig["strategy"])

            # Track performance
            track_strategy_performance()

            # Calculate sleep time to check every minute
            elapsed_time = time.time() - cycle_start_time
            sleep_time = max(0, 60 - elapsed_time)
            if sleep_time > 0:
                logger.info(f"Waiting {sleep_time:.2f} seconds until next check...")
                time.sleep(sleep_time)
        except Exception as e:
            logger.error(f"Error in run_strategy_for_symbol: {str(e)}")
            time.sleep(60)

def thread_wrapper(symbol, timeframe, count, strategies, config):
    last_cycle_time = [time.time()]
    cycle_lock = threading.Lock()  # Add lock to prevent concurrent cycles

    def watchdog():
        while True:
            time.sleep(10)
            current_time = time.time()
            if current_time - last_cycle_time[0] > 120:
                logger.error(f"Thread for {symbol} appears to be stuck. Last cycle was {current_time - last_cycle_time[0]:.2f} seconds ago.")
                logger.info(f"Attempting to restart thread for {symbol}...")
                try:
                    positions = mt5.positions_get(symbol=symbol)
                    logger.info(f"Open positions for {symbol}: {positions if positions else 'None'}")
                    last_log = logger.handlers[0].baseFilename
                    with open(last_log, 'r') as f:
                        lines = f.readlines()
                        last_lines = lines[-5:] if len(lines) >= 5 else lines
                        logger.info(f"Last {len(last_lines)} log lines:\n{''.join(last_lines)}")
                except Exception as e:
                    logger.error(f"Error in watchdog while gathering info: {str(e)}")
                thread = threading.Thread(target=thread_wrapper, args=(symbol, timeframe, count, strategies, config), daemon=True)
                thread.start()
                return

    watchdog_thread = threading.Thread(target=watchdog, daemon=True)
    watchdog_thread.start()

    try:
        while True:
            with cycle_lock:  # Use lock to prevent concurrent cycles
                if not ensure_mt5_connection():  # Check connection before each cycle
                    logger.error(f"MT5 connection lost for {symbol}. Waiting to reconnect...")
                    time.sleep(30)
                    continue
                    
                run_strategy_for_symbol(symbol, timeframe, count, strategies, config)
                last_cycle_time[0] = time.time()
    except Exception as e:
        logger.error(f"Thread for {symbol} failed: {str(e)}. Watchdog will attempt to restart.")

def main():
    try:
        config = load_config()
        logger = setup_logging()
        if logger is None:
            print("Failed to setup logging. Exiting...")
            sys.exit(1)

        if not initialize_mt5():
            logger.error("Failed to initialize MT5 after multiple attempts. Exiting...")
            sys.exit(1)
        logger.info("MT5 initialized successfully")

        load_last_trade_times()
        load_active_trades()

        strategies = [
            ("mmc_combo_strategy", MMCComboStrategy()),
            ("mmc", mmc_strategy()),
            ("mmxm", mmxm()),
            ("msb_retest", msb_retest()),
            ("order_block", order_block()),
            ("ote", ote()),
            ("amd_strategy", amd_strategy()),
            ("judas_swing", judas_swing())
        ]

        timeframe_str = config.get("timeframe", "TIMEFRAME_M15")
        timeframe = getattr(mt5, timeframe_str, mt5.TIMEFRAME_M15)
        candle_count = config.get("candle_count", 50)

        threads = []
        for symbol in config.get("symbols", ["XAUUSD"]):
            logger.info(f"Starting thread for symbol: {symbol}")
            thread = threading.Thread(
                target=thread_wrapper,
                args=(symbol, timeframe, candle_count, strategies, config),
                daemon=True
            )
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join()
    except KeyboardInterrupt:
        logger.info("Keyboard interrupt received. Shutting down...")
        save_last_trade_times()
        save_active_trades()
        mt5.shutdown()
        sys.exit(0)
    except Exception as e:
        logger.error(f"Unhandled exception in main: {str(e)}")
        sys.exit(1)

# Add this function to repair the trade log CSV if malformed lines are present
def repair_trade_log_csv():
    csv_file = TRADE_LOG_FILE
    if not os.path.exists(csv_file):
        return
    try:
        with open(csv_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        if not lines:
            return
        header = lines[0]
        num_fields = len(next(csv.reader([header])))
        cleaned_lines = [header]
        for line in lines[1:]:
            fields = list(csv.reader([line]))[0]
            if len(fields) > num_fields:
                # Trim extra fields
                fields = fields[:num_fields]
            elif len(fields) < num_fields:
                # Pad missing fields
                fields += [''] * (num_fields - len(fields))
            cleaned_lines.append(','.join(fields) + '\n')
        # Backup old file
        shutil.copy(csv_file, csv_file + '.bak')
        with open(csv_file, 'w', encoding='utf-8') as f:
            f.writelines(cleaned_lines)
        logger.info(f"Trade log CSV repaired: {csv_file}")
    except Exception as e:
        logger.error(f"Error repairing trade log CSV: {str(e)}")

# Call this at startup
repair_trade_log_csv()

class mmc_strategy:
    def __init__(self):
        self.trade_count_today = 0
        self.max_drawdown_reached = False
        self.last_trade_day = None
        self.loss_streak = {'bullish': 0, 'bearish': 0}

    def execute(self, symbol, prices, df, equity, allow_multiple_trades):
        try:
            now_utc = datetime.now(timezone.utc)
            today = now_utc.date()
            if self.last_trade_day != today:
                self.trade_count_today = 0
                self.last_trade_day = today
                self.loss_streak = {'bullish': 0, 'bearish': 0}

            # Session filter: NY/LDN overlap
            if not datetime.strptime('12:30', '%H:%M').time() <= now_utc.time() <= datetime.strptime('16:30', '%H:%M').time():
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            # Avoid Monday(0) & Friday(4)
            if now_utc.weekday() in (0, 4):
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            # Daily trade cap
            if self.trade_count_today >= 3:
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            if df is None or df.empty:
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            # Simple accumulation filter
            acc_range = max(prices[-15:]) - min(prices[-15:])
            if acc_range / np.mean(prices[-15:]) > 0.002:
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            # Simple sweep detection
            direction = 'bullish' if prices[-1] < min(prices[-16:-1]) else 'bearish' if prices[-1] > max(prices[-16:-1]) else None
            if direction is None:
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            # CHOCH placeholder
            if direction == 'bullish' and prices[-1] <= prices[-2]:
                return {"success": True, "is_win": False, "risk_amount": 0.0}
            if direction == 'bearish' and prices[-1] >= prices[-2]:
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            atr = calculate_atr(df)
            if atr is None:
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            tick = mt5.symbol_info_tick(symbol)
            if tick is None:
                return {"success": True, "is_win": False, "risk_amount": 0.0}

            order_type = mt5.ORDER_TYPE_BUY if direction == 'bullish' else mt5.ORDER_TYPE_SELL
            price = tick.ask if order_type == mt5.ORDER_TYPE_BUY else tick.bid
            sl = price - (atr * 1.5) if order_type == mt5.ORDER_TYPE_BUY else price + (atr * 1.5)
            sl_points = abs(price - sl) / mt5.symbol_info(symbol).point
            lot_size = calculate_position_size(symbol, equity, atr, sl_points)
            tp1 = price + (sl_points * mt5.symbol_info(symbol).point) if order_type == mt5.ORDER_TYPE_BUY else price - (sl_points * mt5.symbol_info(symbol).point)
            tp2 = price + (sl_points * 2 * mt5.symbol_info(symbol).point) if order_type == mt5.ORDER_TYPE_BUY else price - (sl_points * 2 * mt5.symbol_info(symbol).point)

            success = execute_trade(symbol, order_type, price, sl, tp1, tp2, lot_size, "mmc")
            if success:
                self.trade_count_today += 1
            return {"success": success, "is_win": success, "risk_amount": equity * 0.01}
        except Exception as e:
            logger.error(f"Error in mmc_strategy: {str(e)}")
            return {"success": False, "is_win": False, "risk_amount": 0.0}

# ML model warning handling (if not already robust in MMCComboStrategy)
try:
    from STOCKDATA.modules.ml_filter import MLTradeFilter
except ImportError:
    class MLTradeFilter:
        def allow_trade(self, features):
            logger.warning("ML model not found. All trades will be allowed.")
            return True

MAX_PRICE_DIFF_PCT = 1.0  # Max allowed % difference between live price and candle close before skipping trades

if __name__ == "__main__":
    main()


